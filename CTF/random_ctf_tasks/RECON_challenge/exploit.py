import angr, claripy
import sys

START 		= 0x04011B0
FIND  		= 0x0401269
AVOID 		= [0x4011D2, 0x4012AF]

BUFF 		= 0x0040D000
BUFF_CPY 	= BUFF + 0x200
ARGV 		= BUFF + 0x1060
STACK_ADDR 	= BUFF + 0x1100
ARGC_ADDR 	= STACK_ADDR + 0x4
ARGV_ADDR 	= STACK_ADDR + 0x8

p = angr.Project('./recon_challenge_2016_unpacked[UpxUnpacker0.2].exe')

# hook call to malloc that copies argv[1]
@p.hook(0x4011FE, length=5)
def set_rax(state):
    state.regs.eax = BUFF_CPY

state = p.factory.blank_state(addr=START)

# stack
state.regs.esp = claripy.BVV(STACK_ADDR, 32)

# remove unconstrained warnings
state.regs.esi = claripy.BVV(0xdeadbeef, 32)
state.regs.edi = claripy.BVV(0xcafebabe, 32)
state.regs.ebx = claripy.BVV(0xdeadbeef, 32)
state.regs.ebp = claripy.BVV(0xcafebabe, 32)
# argc
state.memory.store(ARGC_ADDR, claripy.BVV(2, 32), endness=state.arch.memory_endness)
# *argv
state.memory.store(ARGV_ADDR, claripy.BVV(ARGV, 32), endness=state.arch.memory_endness)
# argv[1]
state.memory.store(ARGV + 0x4, claripy.BVV(BUFF, 32), endness=state.arch.memory_endness)
# symbuff
sim_flag = claripy.BVS('flag', 8 * 32)
state.memory.store(BUFF, sim_flag)

sim = p.factory.simulation_manager(state)
sim.use_technique(angr.exploration_techniques.Explorer(find=FIND, avoid=AVOID))

print(sim.run())

result = sim.found[0].solver.eval(sim_flag)

print('[*] flag: {}'.format(bytes.fromhex(hex(result)[2:]).decode('utf-8')))
